
==================== Tidy Core ====================
2023-02-08 12:52:58.943979224 UTC

Result size of Tidy Core
  = {terms: 69, types: 59, coercions: 0, joins: 0/1}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule1_r1Im :: ghc-prim:GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
$trModule1_r1Im = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule2_r1Iv :: ghc-prim:GHC.Types.TrName
[GblId, Unf=OtherCon []]
$trModule2_r1Iv = ghc-prim:GHC.Types.TrNameS $trModule1_r1Im

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule3_r1Iw :: ghc-prim:GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
$trModule3_r1Iw = "Main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule4_r1Ix :: ghc-prim:GHC.Types.TrName
[GblId, Unf=OtherCon []]
$trModule4_r1Ix = ghc-prim:GHC.Types.TrNameS $trModule3_r1Iw

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Main.$trModule :: ghc-prim:GHC.Types.Module
[GblId, Unf=OtherCon []]
Main.$trModule
  = ghc-prim:GHC.Types.Module $trModule2_r1Iv $trModule4_r1Ix

-- RHS size: {terms: 20, types: 17, coercions: 0, joins: 0/1}
good :: [Int] -> Int
[GblId, Arity=1, Unf=OtherCon []]
good
  = \ (xs_a1hA :: [Int]) ->
      scctick<good>
      let {
        n_a1hB :: Int
        [LclId]
        n_a1hB
          = scctick<good.n>
            length
              @[]
              Data.Foldable.$fFoldable[]
              @Integer
              (enumFromTo @Integer GHC.Enum.$fEnumInteger 1 10000) } in
      $ @ghc-prim:GHC.Types.LiftedRep
        @[Int]
        @Int
        (sum @[] Data.Foldable.$fFoldable[] @Int GHC.Num.$fNumInt)
        (fmap
           @[]
           GHC.Base.$fFunctor[]
           @Int
           @Int
           (\ (x_a1hD :: Int) ->
              scctick<good.f> + @Int GHC.Num.$fNumInt x_a1hD n_a1hB)
           xs_a1hA)

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
bad :: [Int] -> Int
[GblId, Arity=1, Unf=OtherCon []]
bad
  = \ (xs_a14z :: [Int]) ->
      scctick<bad>
      $ @ghc-prim:GHC.Types.LiftedRep
        @[Int]
        @Int
        (sum @[] Data.Foldable.$fFoldable[] @Int GHC.Num.$fNumInt)
        (fmap
           @[]
           GHC.Base.$fFunctor[]
           @Int
           @Int
           (\ (x_a14B :: Int) ->
              scctick<bad.f>
              + @Int
                GHC.Num.$fNumInt
                x_a14B
                (length
                   @[]
                   Data.Foldable.$fFoldable[]
                   @Integer
                   (enumFromTo @Integer GHC.Enum.$fEnumInteger 1 10000)))
           xs_a14z)

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
main :: IO ()
[GblId]
main
  = scctick<main>
    $ @ghc-prim:GHC.Types.LiftedRep
      @Int
      @(IO ())
      (. @String @(IO ()) @Int putStrLn (show @Int GHC.Show.$fShowInt))
      (bad
         (scctick<main.test_values>
          replicate
            @Int (ghc-prim:GHC.Types.I# 5000#) (ghc-prim:GHC.Types.I# 1#)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
:Main.main :: IO ()
[GblId]
:Main.main = GHC.TopHandler.runMainIO @() main


